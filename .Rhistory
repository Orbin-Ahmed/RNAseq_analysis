#note that these loadings have a magnitude and a direction (this is the basis for making a PCA plot)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
# Visualize your PCA result ------------------
#lets first plot any two PCs against each other
#We know how much each sample contributes to each PC (loadings), so let's plot
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
aes(x=PC1, y=PC2) +
geom_point(size=4) +
# geom_label() +
# stat_ellipse() +
xlab(paste0("PC1 (",pc.per[1],"%",")")) +
ylab(paste0("PC2 (",pc.per[2],"%",")")) +
labs(title="PCA plot",
caption=paste0("produced on ", Sys.time())) +
coord_fixed() +
theme_bw()
# now create a small multiple PCA plot
pca.res.df <- pca.res$x[,1:4] %>% # note that this is the first time you've seen the 'pipe' operator from the magrittr package
as_tibble() %>%
add_column(treatment) %>%
add_column(genotype) %>%
add_column(sampleName)
pca.pivot <- pivot_longer(pca.res.df, # dataframe to be pivoted
cols = PC1:PC4, # column names to be stored as a SINGLE variable
names_to = "PC", # name of that new variable (column)
values_to = "loadings") # name of new variable (column) storing all the values (data)
ggplot(pca.pivot) +
aes(x=sampleName, y=loadings, fill=treatment) + # you could iteratively 'paint' different covariates onto this plot using the 'fill' aes. Try doing this with the genotype variable you created above.
geom_bar(stat="identity") +
facet_wrap(~PC) +
labs(title="PCA 'small multiples' plot",
caption=paste0("produced on ", Sys.time())) +
theme_bw() +
coord_flip()
# the essentials ----
library(tidyverse)
library(rhdf5)
library(edgeR)
archs4.mouse <- "mouse_matrix_v10.h5" # if you placed the hdf5 file in your working directory, just use "human_matrix_v8.h5" as the path
all.samples.mouse <- h5read(archs4.mouse, name="meta/samples/geo_accession")
library(edgeR)
archs4.mouse <- "mouse_matrix_v10.h5" # if you placed the hdf5 file in your working directory, just use "human_matrix_v8.h5" as the path
all.samples.mouse <- h5read(archs4.mouse, name="meta/samples/geo_accession")
mySamples <- c("GSM2310941", # WT_unstim_rep1
"GSM2310942", # WT_unstim_rep2
"GSM2310943", # Ripk3_unstim_rep1
"GSM2310944", # Ripk3_unstim_rep2
"GSM2310945", # Ripk3Casp8_unstim_rep1
"GSM2310946", # Ripk3Casp8_unstim_rep2
"GSM2310947", # WT_LPS.6hr_rep1
"GSM2310948", # WT_LPS.6hr_rep2
"GSM2310949", # Ripk3_LPS.6hr_rep1
"GSM2310950", # Ripk3_LPS.6hr_rep2
"GSM2310951", # Ripk3Casp8_LPS.6hr_rep1
"GSM2310952") # Ripk3Casp8_LPS.6hr_rep2
my.sample.locations <- which(all.samples.mouse %in% mySamples)
genes <- h5read(archs4.mouse, "meta/genes/gene_symbol")
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
expression <- t(expression)
rownames(expression) <- genes
colnames(expression) <- all.samples.mouse[my.sample.locations]
archs4.dgelist <- DGEList(expression)
archs4.cpm <- cpm(archs4.dgelist)
keepers <- rowSums(archs4.cpm>1)>=2
archs4.dgelist.filtered <- archs4.dgelist[keepers,]
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.filtered.norm.log2.cpm <- cpm(archs4.dgelist.filtered.norm, log=TRUE)
sample_source_name <- h5read(archs4.mouse, "meta/samples/source_name_ch1")
sample_title <- h5read(archs4.mouse, name="meta/samples/title")
sample_characteristics<- h5read(archs4.mouse, name="meta/samples/characteristics_ch1")
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
Sample_source = sample_source_name[my.sample.locations],
Sample_characteristics = sample_characteristics[my.sample.locations])
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
genotype = c("WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8", "WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8"),
treatment = c("unstim", "unstim", "unstim", "unstim", "unstim", "unstim", "LPS", "LPS", "LPS", "LPS", "LPS", "LPS"))
pca.res <- prcomp(t(archs4.filtered.norm.log2.cpm), scale.=F, retx=T)
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
aes(x=PC1, y=PC2, color=treatment, shape=genotype) +
geom_point(size=4) +
# geom_label() +
# stat_ellipse() +
xlab(paste0("PC1 (",pc.per[1],"%",")")) +
ylab(paste0("PC2 (",pc.per[2],"%",")")) +
labs(title="PCA plot",
caption=paste0("produced on ", Sys.time())) +
coord_fixed() +
theme_bw()
# Load packages ------
# nothing new here...you should already have all these packages in your R package library
library(tidyverse)
library(rhdf5)
library(edgeR)
# load ARCHS4 database -----
# you should have already downloaded the most recent versions of mouse and human RNAseq data from ARCHS4 in hdf5 format
# begin by creating file paths that point to the hdf5 archs4 files
# because of the size of these files, feel free to skip the human data and just work with mouse
# archs4.human <- "archs4_gene_human_v2.1.2.h5"
archs4.mouse <- "archs4_gene_mouse_v2.1.2.h5"
# use the h5 list (h5ls) function from the rhdf5 package to look at the contents of these databases
# h5ls(archs4.human)
h5ls(archs4.mouse)
# 717,966 samples from mouse!
all.samples.mouse <- h5read(archs4.mouse, name="meta/samples/geo_accession")
dim(all.samples.mouse)
# query ARCHS4 database ----
# choose your samples based on GEO or SRA ID
mySamples <- c("GSM2310941", # WT_unstim_rep1
"GSM2310942", # WT_unstim_rep2
"GSM2310943", # Ripk3_unstim_rep1
"GSM2310944", # Ripk3_unstim_rep2
"GSM2310945", # Ripk3Casp8_unstim_rep1
"GSM2310946", # Ripk3Casp8_unstim_rep2
"GSM2310947", # WT_LPS.6hr_rep1
"GSM2310948", # WT_LPS.6hr_rep2
"GSM2310949", # Ripk3_LPS.6hr_rep1
"GSM2310950", # Ripk3_LPS.6hr_rep2
"GSM2310951", # Ripk3Casp8_LPS.6hr_rep1
"GSM2310952") # Ripk3Casp8_LPS.6hr_rep2
# Identify columns to be extracted from ARCHS4 database
my.sample.locations <- which(all.samples.mouse %in% mySamples) # first time you've seen the %in% operator.
# extract gene symbols from the metadata
genes <- h5read(archs4.mouse, "meta/genes/gene_symbol")
# Extract expression data from ARCHS4 ----
expression <- h5read(archs4.mouse, "data/expression",
index=list(my.sample.locations, 1:length(genes)))
# transpose to get genes as rows and samples as columns
expression <- t(expression)
rownames(expression) <- genes
colnames(expression) <- all.samples.mouse[my.sample.locations]
colSums(expression) #this shows the sequencing depth for each of the samples you've extracted
archs4.dgelist <- DGEList(expression)
archs4.cpm <- cpm(archs4.dgelist)
colSums(archs4.cpm)
# Filter and normalize the extracted data ----
table(rowSums(archs4.dgelist$counts==0)==12)
keepers <- rowSums(archs4.cpm>1)>=2
archs4.dgelist.filtered <- archs4.dgelist[keepers,]
dim(archs4.dgelist.filtered)
archs4.dgelist.filtered.norm <- calcNormFactors(archs4.dgelist.filtered, method = "TMM")
archs4.filtered.norm.log2.cpm <- cpm(archs4.dgelist.filtered.norm, log=TRUE)
# Extract sample metadata from ARCHS4 to create a study design file ----
# extract the sample source
sample_source_name <- h5read(archs4.mouse, "meta/samples/source_name_ch1")
# extract sample title
sample_title <- h5read(archs4.mouse, name="meta/samples/title")
# extract sample characteristics
sample_characteristics<- h5read(archs4.mouse, name="meta/samples/characteristics_ch1")
# let's try putting this all together in a study design file
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
Sample_source = sample_source_name[my.sample.locations],
Sample_characteristics = sample_characteristics[my.sample.locations])
#based on what we extracted from ARCHS4 above, lets customize and clean-up this study design file
studyDesign <- tibble(Sample_title = sample_title[my.sample.locations],
genotype = c("WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8", "WT", "WT", "Ripk3", "Ripk3", "Ripk3Casp8", "Ripk3Casp8"),
treatment = c("unstim", "unstim", "unstim", "unstim", "unstim", "unstim", "LPS", "LPS", "LPS", "LPS", "LPS", "LPS"))
#capture experimental variables as factors from this study design
genotype <- factor(studyDesign$genotype)
treatment <- factor(studyDesign$treatment)
sampleName <- studyDesign$Sample_title
# Principal component analysis (PCA) -------------
pca.res <- prcomp(t(archs4.filtered.norm.log2.cpm), scale.=F, retx=T)
#look at pca.res in environment
ls(pca.res)
summary(pca.res) # Prints variance summary for all principal components.
pca.res$rotation #$rotation shows you how much each gene influenced each PC (called 'scores')
pca.res$x #$x shows you how much each sample influenced each PC (called 'loadings')
#note that these loadings have a magnitude and a direction (this is the basis for making a PCA plot)
pc.var<-pca.res$sdev^2 #sdev^2 gives you the eigenvalues
pc.per<-round(pc.var/sum(pc.var)*100, 1)
pc.per
# Visualize your PCA result ------------------
#lets first plot any two PCs against each other
#We know how much each sample contributes to each PC (loadings), so let's plot
pca.res.df <- as_tibble(pca.res$x)
ggplot(pca.res.df) +
aes(x=PC1, y=PC2) +
geom_point(size=4) +
# geom_label() +
# stat_ellipse() +
xlab(paste0("PC1 (",pc.per[1],"%",")")) +
ylab(paste0("PC2 (",pc.per[2],"%",")")) +
labs(title="PCA plot",
caption=paste0("produced on ", Sys.time())) +
coord_fixed() +
theme_bw()
# now create a small multiple PCA plot
pca.res.df <- pca.res$x[,1:4] %>% # note that this is the first time you've seen the 'pipe' operator from the magrittr package
as_tibble() %>%
add_column(treatment) %>%
add_column(genotype) %>%
add_column(sampleName)
pca.pivot <- pivot_longer(pca.res.df, # dataframe to be pivoted
cols = PC1:PC4, # column names to be stored as a SINGLE variable
names_to = "PC", # name of that new variable (column)
values_to = "loadings") # name of new variable (column) storing all the values (data)
ggplot(pca.pivot) +
aes(x=sampleName, y=loadings, fill=treatment) + # you could iteratively 'paint' different covariates onto this plot using the 'fill' aes. Try doing this with the genotype variable you created above.
geom_bar(stat="identity") +
facet_wrap(~PC) +
labs(title="PCA 'small multiples' plot",
caption=paste0("produced on ", Sys.time())) +
theme_bw() +
coord_flip()
# Load packages -----
library(tidyverse) # you know it well by now!
library(limma) # venerable package for differential gene expression using linear modeling
library(edgeR)
library(gt)
library(DT)
library(plotly)
# Load packages -----
library(tidyverse) # you know it well by now!
library(limma) # venerable package for differential gene expression using linear modeling
library(edgeR)
library(gt)
library(DT)
library(plotly)
# Set up your design matrix ----
group <- factor(targets$group)
design <- model.matrix(~0 + group)
# Set up your design matrix ----
group <- factor(targets$group)
targets$group
# Set up your design matrix ----
group <- factor(targets$treatment)
design <- model.matrix(~0 + group)
colnames(design) <- levels(group)
# Model mean-variance trend and fit linear model to data ----
# Use VOOM function from Limma package to model the mean-variance relationship
v.DEGList.filtered.norm <- voom(myDGEList.filtered.norm, design, plot = TRUE)
# fit a linear model to your data
fit <- lmFit(v.DEGList.filtered.norm, design)
# Contrast matrix ----
contrast.matrix <- makeContrasts(infection = disease - healthy,
levels=design)
# Contrast matrix ----
contrast.matrix <- makeContrasts(infection = Vehicle - Dexamethasone,
levels=design)
# extract the linear model fit -----
fits <- contrasts.fit(fit, contrast.matrix)
#get bayesian stats for your linear model fit
ebFit <- eBayes(fits)
# TopTable to view DEGs -----
myTopHits <- topTable(ebFit, adjust ="BH", coef=1, number=40000, sort.by="logFC")
# convert to a tibble
myTopHits.df <- myTopHits %>%
as_tibble(rownames = "geneID")
gt(myTopHits.df)
# now plot
vplot <- ggplot(myTopHits.df) +
aes(y=-log10(adj.P.Val), x=logFC, text = paste("Symbol:", geneID)) +
geom_point(size=2) +
#geom_hline(yintercept = -log10(0.01), linetype="longdash", colour="grey", size=1) +
#geom_vline(xintercept = 1, linetype="longdash", colour="#BE684D", size=1) +
#geom_vline(xintercept = -1, linetype="longdash", colour="#2C467A", size=1) +
#annotate("rect", xmin = 1, xmax = 12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#BE684D") +
#annotate("rect", xmin = -1, xmax = -12, ymin = -log10(0.01), ymax = 7.5, alpha=.2, fill="#2C467A") +
labs(title="Volcano plot",
subtitle = "Cutaneous leishmaniasis",
caption=paste0("produced on ", Sys.time())) +
theme_bw()
# Now make the volcano plot above interactive with plotly
ggplotly(vplot)
# decideTests to pull out the DEGs and make Venn Diagram ----
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=2)
# take a look at what the results of decideTests looks like
head(results)
summary(results)
vennDiagram(results, include="up")
# retrieve expression data for your DEGs ----
head(v.DEGList.filtered.norm$E)
colnames(v.DEGList.filtered.norm$E) <- sampleLabels
diffGenes <- v.DEGList.filtered.norm$E[results[,1] !=0,]
head(diffGenes)
dim(diffGenes)
#convert your DEGs to a dataframe using as_tibble
diffGenes.df <- as_tibble(diffGenes, rownames = "geneID")
# create interactive tables to display your DEGs ----
datatable(diffGenes.df,
extensions = c('KeyTable', "FixedHeader"),
caption = 'Table 1: DEGs in cutaneous leishmaniasis',
options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c("10", "25", "50", "100"))) %>%
formatRound(columns=c(2:11), digits=2)
#write your DEGs to a file
write_tsv(diffGenes.df,"DiffGenes.txt") #NOTE: this .txt file can be directly used for input into other clustering or network analysis tools (e.g., String, Clust (https://github.com/BaselAbujamous/clust, etc.)
# Load packages -----
library(tidyverse)
library(limma) #we only use limma in this script for the 'avearrays' function
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
setPackageName()
setRepositories()
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
# Load packages -----
library(tidyverse)
library(limma) #we only use limma in this script for the 'avearrays' function
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(gameofthrones) #because...why not.  Install using 'devtools::install_github("aljrico/gameofthrones")'
devtools::install_github("aljrico/gameofthrones")
install.packages("gameofthrones")
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(gameofthrones) #because...why not.  Install using 'devtools::install_github("aljrico/gameofthrones")'
library(heatmaply) #for making interactive heatmaps using plotly
library(d3heatmap) #for making interactive heatmaps using D3
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(gameofthrones) #because...why not.  Install using 'devtools::install_github("aljrico/gameofthrones")'
install.packages("devtools")
devtools::install_github("aljrico/gameofthrones")
# Load packages -----
library(tidyverse)
library(limma) #we only use limma in this script for the 'avearrays' function
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(gameofthrones) #because...why not.  Install using 'devtools::install_github("aljrico/gameofthrones")'
library(heatmaply) #for making interactive heatmaps using plotly
library(d3heatmap) #for making interactive heatmaps using D3
devtools::install_github("rstudio/d3heatmap")
# Load packages -----
library(tidyverse)
library(limma) #we only use limma in this script for the 'avearrays' function
library(RColorBrewer) #need colors to make heatmaps
library(gplots) #the heatmap2 function in this package is a primary tool for making heatmaps
library(gameofthrones) #because...why not.  Install using 'devtools::install_github("aljrico/gameofthrones")'
library(heatmaply) #for making interactive heatmaps using plotly
library(d3heatmap) #for making interactive heatmaps using D3
# Choose your color pallette ----
#Some useful examples: colorpanel(40, "darkblue", "yellow", "white"); heat.colors(75); cm.colors(75); rainbow(75); redgreen(75); library(RColorBrewer); rev(brewer.pal(9,"Blues")[-1]).
myheatcolors1 <- bluered(75) #this is from the 'colorpanel' function in gplots (same package that heatmap.2 comes from)
display.brewer.all()
display.brewer.all(colorblindFriendly = TRUE)
# lots of easy ways to assemble your own color palette, including:
# 1). use 'colorRampPalette' function from the grDevices package
myheatcolors2 <- colorRampPalette(colors=c("blue","white","red"))(100)
# 2). use rcolorbrewer to choose any palette by name and n colors from that palette
myheatcolors3 <- brewer.pal(name="RdBu", n=11)
# 3). paste in your own hex codes using the Sip app (or other tools)
myheatcolors3 <- c("#fed976", "#268f9c")
# 4). have some fun with outside color packages (e.g. GameOfThrones)
got_palette <- got(75, option = "Arya")
# Data----
# you can make a heatmap out of any datamatrix
# we'll use our 'diffgenes' datamatrix that was produced at the end of the last class in the Step 5 script
# as a reminder, this was produced as follows
results <- decideTests(ebFit, method="global", adjust.method="BH", p.value=0.01, lfc=2)
colnames(v.DEGList.filtered.norm$E) <- sampleLabels
diffGenes <- v.DEGList.filtered.norm$E[results[,1] !=0,]
dim(diffGenes)
# Cluster DEGs ----
#begin by clustering the genes (rows) in each set of differentially expressed genes
# we use the 'cor' function and the pearson method for finding all pairwise correlations of genes
# '1-cor' converts this to a 0-2 scale for each of these correlations, which can then be used to calculate a distance matrix using 'as.dist'
clustRows <- hclust(as.dist(1-cor(t(diffGenes), method="pearson")), method="complete")
#now cluster your samples (columns)
#we may not acutally use this clustering result, but it's good to have just in case
clustColumns <- hclust(as.dist(1-cor(diffGenes, method="spearman")), method="complete") #cluster columns by spearman correlation
#Cut the resulting tree and create color vector for clusters.
#Vary the cut height (h =) to give more or fewer clusters, or use force k= number of clusters
#we'll look at these clusters in more detail later
module.assign <- cutree(clustRows, k=2)
#now assign a color to each module (makes it easy to identify and manipulate)
module.color <- rainbow(length(unique(module.assign)), start=0.1, end=0.9)
module.color <- module.color[as.vector(module.assign)]
# Produce a static heatmap of DEGs ----
#plot the hclust results as a heatmap
heatmap.2(diffGenes,
Rowv=as.dendrogram(clustRows),
Colv=as.dendrogram(clustColumns),
RowSideColors=module.color,
col=rev(myheatcolors3), scale='row', labRow=NA,
density.info="none", trace="none",
cexRow=1, cexCol=1, margins=c(8,20))
# Make interactive heatmap ----
#first, we'll make an interactive heatmap using plotly (https://plot.ly/)
heatmaply(diffGenes,
colors = myheatcolors2,
Rowv=as.dendrogram(clustRows),
RowSideColors=module.color,
#showticklabels=c(FALSE,FALSE),
scale='row')
# now let's try using D3 to create an html widget version of our heatmap
d3heatmap(diffGenes,
colors = myheatcolors2,
Rowv=as.dendrogram(clustRows),
row_side_colors = module.color,
scale='row')
# OPTIONAL: simplify heatmap ----
#notice that the heatmap includes ALL the columns from your dataset
#a useful way to simplify heatmaps, especially when there are many conditions, is to average your biological replicates and display only one column per condition
#rerun the heatmap script above using diffData.AVG as input instead of diffData
colnames(diffGenes) <- targets$treatment
#now an old function from the limma package to average your replicates
diffGenes.AVG <- avearrays(diffGenes)
# View modules of co-regulated genes ----
# view your color assignments for the different clusters
names(module.color) <- names(module.assign)
module.assign.df <- as_tibble(as.list(module.assign))
module.assign.pivot <- pivot_longer(module.assign.df, # dataframe to be pivoted
cols = 1:2307, # column names to be stored as a SINGLE variable
names_to = "geneID", # name of that new variable (column)
values_to = "module") # name of new variable (column) storing all the values (data)
module.assign.pivot <- module.assign.pivot %>%
mutate(moduleColor = case_when(
module == 1 ~ "#FF9900",
module == 2 ~ "#FF0099"))
ggplot(module.assign.pivot) +
aes(module) +
geom_bar(aes(fill=moduleColor)) +
theme_bw()
module.assign.pivot <- pivot_longer(module.assign.df, # dataframe to be pivoted
cols = 1:203, # column names to be stored as a SINGLE variable
names_to = "geneID", # name of that new variable (column)
values_to = "module") # name of new variable (column) storing all the values (data)
module.assign.pivot <- module.assign.pivot %>%
mutate(moduleColor = case_when(
module == 1 ~ "#FF9900",
module == 2 ~ "#FF0099"))
ggplot(module.assign.pivot) +
aes(module) +
geom_bar(aes(fill=moduleColor)) +
theme_bw()
#choose a cluster(s) of interest by selecting the corresponding number based on the previous graph
modulePick <- 2 #use 'c()' to grab more than one cluster from the heatmap.  e.g., c(1,2)
#now we pull out the genes from this module using a fancy subsetting operation on a named vector
myModule <- diffGenes[names(module.assign[module.assign %in% modulePick]),]
hrsub <- hclust(as.dist(1-cor(t(myModule), method="pearson")), method="complete")
# Create heatmap for chosen sub-cluster.
heatmap.2(myModule,
Rowv=as.dendrogram(hrsub),
Colv=NA,
labRow = NA,
col=rev(myheatcolors3), scale="row",
density.info="none", trace="none",
RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
# Export modules for downstream analysis ----
#prints out genes in the order you see them in the cluster
moduleSymbols <- tibble(geneID = rev(hrsub$labels[hrsub$order]))
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol")
moduleData <- diffGenes[moduleSymbols$geneID,]
moduleData.df <- as_tibble(moduleData, rownames = "geneSymbol")
write_tsv(moduleData.df,"module_upRegulated.tsv")
# OPTIONAL: make heatmap from an a priori list of genes ----
#read in a text file containing the genes (with expression data) you want to include in the heatmap
mySelectedGenes <- read_tsv("path/to/file/with/selected/genes/with/data")
# OPTIONAL: make heatmap from an a priori list of genes ----
#read in a text file containing the genes (with expression data) you want to include in the heatmap
mySelectedGenes <- mydata.filter
#rather than reading a file in, this tibble could also come from dplyr operations in step 3 script
#convert to a matrix so you can carry out clustering
mySelectedGenes.matrix <- as.matrix(mySelectedGenes)
#you may (or may not) want to cluster your selected genes
hr <- hclust(as.dist(1-cor(t(mySelectedGenes.matrix), method="pearson")), method="complete") #cluster rows by pearson correlation
#you may (or may not) want to cluster your selected genes
hr <- hclust(as.dist(1-cor(t(mySelectedGenes.matrix), method="Dexamethasone")), method="complete") #cluster rows by pearson correlation
hc <- hclust(as.dist(1-cor(mySelectedGenes.matrix, method="Vehicle")), method="average") #cluster columns by spearman correlation
pearson
#you may (or may not) want to cluster your selected genes
hr <- hclust(as.dist(1-cor(t(mySelectedGenes.matrix), method="pearson")), method="complete") #cluster rows by pearson correlation
hc <- hclust(as.dist(1-cor(mySelectedGenes.matrix, method="spearman")), method="average") #cluster columns by spearman correlation
#make heatmap
heatmap.2(mySelectedGenes.matrix,
Rowv=NA, Colv=NA,
col=myheatcol,
scale="row", density.info="none",
trace="none", labCol=NA,
cexRow=1.5, cexCol=1, margins=c(8,20), key = F)
# the essentials ----
library(tidyverse)
library(gplots)
library(RColorBrewer)
myheatcolors <- rev(brewer.pal(name="RdBu", n=11))
clustRows <- hclust(as.dist(1-cor(t(diffGenes), method="pearson")), method="complete") #cluster rows by pearson correlation
clustColumns <- hclust(as.dist(1-cor(diffGenes, method="spearman")), method="complete")
module.assign <- cutree(clustRows, k=2)
module.color <- rainbow(length(unique(module.assign)), start=0.1, end=0.9)
module.color <- module.color[as.vector(module.assign)]
heatmap.2(diffGenes,
Rowv=as.dendrogram(clustRows),
Colv=as.dendrogram(clustColumns),
RowSideColors=module.color,
col=myheatcolors, scale='row', labRow=NA,
density.info="none", trace="none",
cexRow=1, cexCol=1, margins=c(8,20))
modulePick <- 2
myModule_up <- diffGenes[names(module.assign[module.assign %in% modulePick]),]
hrsub_up <- hclust(as.dist(1-cor(t(myModule_up), method="pearson")), method="complete")
heatmap.2(myModule_up,
Rowv=as.dendrogram(hrsub_up),
Colv=NA,
labRow = NA,
col=myheatcolors, scale="row",
density.info="none", trace="none",
RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
modulePick <- 1
myModule_down <- diffGenes[names(module.assign[module.assign %in% modulePick]),]
hrsub_down <- hclust(as.dist(1-cor(t(myModule_down), method="pearson")), method="complete")
heatmap.2(myModule_down,
Rowv=as.dendrogram(hrsub_down),
Colv=NA,
labRow = NA,
col=myheatcolors, scale="row",
density.info="none", trace="none",
RowSideColors=module.color[module.assign%in%modulePick], margins=c(8,20))
